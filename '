use engine::{
    game::Board,
    primitives::{ChessPiece, Square},
};

pub fn router() -> RouterBuilder<MyCtx> {
    Router::<MyCtx>::new()
        .query("start", |t| {
            t(|_ctx, _args: ()| ChessJSON::from(Board::default()))
        })
        .mutation("move", |t| {
            t(|_ctx, args: (MoveJSON, ChessJSON)| {
                let (move_data, chess_data) = args;

                let mut chess = Chess::default();
                chess.board = chess_data.board;
                chess.team_to_move = chess_data.team_to_move;

                chess
                    .make_move(
                        Square::from_str(&move_data.origin).unwrap(),
                        Square::from_str(&move_data.destination).unwrap(),
                    )
                    .unwrap();

                return ChessJSON::from(chess);
            })
        })
        // TODO: fen router
        .merge("fen.", Router::<MyCtx>::new())
}

#[derive(Debug, rspc::Type, serde::Serialize, serde::Deserialize)]
struct MoveJSON {
    origin: String,
    destination: String,
    takes: bool,
    piece: ChessPieceVariant,
}

#[derive(Debug, rspc::Type, serde::Serialize, serde::Deserialize)]
struct ChessJSON {
    #[serde(rename = "teamToMove")]
    team_to_move: Team,
    moves: Vec<MoveJSON>,
    board: ChessBoard,
}

impl From<Board> for ChessJSON {
    fn from(board: Board) -> Self {
        Self {
            moves: board.gen_moves(),
            team_to_move: board.team_to_move,
            board: (0..Board::SIZE as u8).map(|index| Square::new(index)).map(|square| if let Some(piece) = board.piece_on(square) && let Some(team) = board.team_on(square) {
                Some( ChessPiece {
                    team,
                    variant: piece,
                })
            } else {
                None
            })
        }
    }
}

impl Into<Board> for ChessJSON {
    fn into(self) -> Board {
        
    }
}

#[deprecated]
impl From<Chess> for ChessJSON {
    fn from(value: Chess) -> Self {
        Self {
            team_to_move: value.team_to_move,
            moves: value
                .generate_legal_moves()
                .iter()
                .map(|m| MoveJSON {
                    piece: m.piece,
                    origin: m.origin.to_string(),
                    destination: m.destination.to_string(),
                    takes: m.takes,
                })
                .collect(),
            board: value.board,
        }
    }
}
